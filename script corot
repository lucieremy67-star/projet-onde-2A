#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Nov 13 15:23:22 2025

@author: lucieremy
"""
########### Importation des librairies utiles ################## 
import numpy as np

import matplotlib.pyplot as plt

########### Initialisation des variables #######################

L= 10 #longueur des plaques
dL= L/10 # intervalle de discrétisation ; dénominateur = nb de segments souhaité (ici 10)
h= 3 # distance entre les plaques
hr= 1 # hauteur entre la plaque du bas et le récepteur
d= 2 # distance entre la fin de la plaque et le récépteur
Lr= 1 # largeur du récépteur
E0= 1 # Eclairement du soleil normalisé en W/m
R= 0.01 # Reflectance de la peinture ie ce que la pleinture reflete >0
Lum0= (E0*R)/np.pi # Luminance dans le cas lambertien A DETERMINER 
M = 0# Emittance A DETERMINER 
n_tours= 5 #Nombre de tours de reflexions a deteminer/modifier en fonction de nos besoins

# Formule: dans le cas lambertien et 3D : L=Pi*M 

#%% Discrétisation des plaques

s = [[0 for j in range(11)] for i in range(2)] # liste qui va contenir les segments discrétisés des plaques 

for i in range (0,2):
    for j in range (0,11): # 10 segments donc 11 démarcations
        s[i][j]=j*dL # "coordonnées des démarcations entre chaque segment
        
print(s)

#%% Calcul des milieux des segments
milieu=[[0 for j in range(10)] for i in range(2)] # liste qui va contenir les "coordonnées" des milieux des segments 

for i in range (0,2):
    for j in range (0,10): # 10 segments
        milieu[i][j]=(s[i][j+1]+s[i][j])/2    #milieu du segment j de la plaque i

#%% Calcul des distances entre tous les milieux

distance=[[0 for j in range(10)] for i in range(10)]  # liste qui contiendra les distances entre un milieu d'une plaque et tous les milieux de l'autre plaque 

for i in range (0,10):
    for j in range (0,10):
        distance[i][j] = np.sqrt((milieu[0][i]-milieu[1][j])**2 + h**2) # d[i][j] donne la distance entre le milieu i d'une plaque et le milieu j de l'autre plaque 
        

#%%Calcul des distances entre les milieux et le récepteur

distance_r=[[0 for j in range(10)] for i in range(2)] # liste qui contiendra les distances entre les milieux[i][j] et le récepteur
distance_r_horiz= [d+(j+0.5)*dL for j in range(10)] #liste qui contiendra les distances horizotale entre le milieux[j] d'une plaque et le projeté du récepteur le leg de l'axe de la plaque

for i in range (2):
    for j in range (10):
        dj=distance_r_horiz[j]
        distance_r[i][j]= np.sqrt((dj)**2 + (h/2)**2) #donne la distance entre le milieu j d'une plaque et le milieu du récepteur 

#%% Calcul des angles entre les milieux

angle=[[0 for j in range(10)] for i in range(10)]  # liste qui contiendra les angles entre un milieu d'une plaque et tous les milieux de l'autre plaque
angle_r=[[0 for j in range(10)] for i in range(2)] # liste qui contiendra les angles entre les milieux[i][j] et le récepteur (côté plaque)
angle_r_prime=[[0 for j in range(10)] for i in range(2)] # liste qui contiendra les angles entre les milieux[i][j] et le récepteur (côté récépteur)


for i in range (0,10):
    for j in range (0,10):
        angle[i][j]= np.arccos(dL/distance[i][j]) # donne l'angle entre le milieu i d'une plaque et le milieu j de l'autre plaque 

for i in range (2):
    for j in range(10):
        angle_r[i][j]= np.arccos(dL/distance_r[i][j]) # donne l'angle entre le milieu j d'une plaque et le milieu du récepteur côté plaque
        angle_r_prime[i][j]= np.arccos(Lr/distance_r[i][j]) # donne l'angle entre le milieu j d'une plaque et le milieu du récepteur côté récpteur
#%% Formules 

def d2phi(Lum_j,dl,dl_prime,theta,theta_prime,d) :
    d2phi = (Lum_j*dl*dl_prime*np.cos(theta)*np.cos(theta_prime))/(d)
    #Formule du flux que Lemarquis nous a donné dans le cas 3D !! A DETERMINER EN 2D
    return d2phi 

#%% Calcul de la quantité de lumière reçue

#Initialisation
E=[[0 for j in range(10)] for i in range(2)] # liste qui va contenir l'éclairement total reçu par segment par tour

#Conditions initiales
milieu_initial=milieu[0][9] #Milieu sur lequel arrive la lumière incidente CHOIX ARBITRAIRE POUR L'INSTANT !!!
plaque_initiale=0 #Plaque contenant le milieu incident
indice_initial=9 #Indice de quel milieu est dans le tableau
Lum=[[0 for j in range(11)] for i in range(2)] #Luminances de chaque plaque à l'instant initial
Lum[plaque_initiale][indice_initial]=Lum0

#Fonctions
def Eij(Lum_j,dl,dl_prime,theta,theta_prime,d): # Energie que le segment j d'une plaque envoie sur le segment i de l'autre plaque
    phi=d2phi(Lum_j,dl,dl_prime,theta,theta_prime,d)
    return phi/dl_prime 

def Ei(Lum_liste,dl,dl_prime,angle_i,angle_i_prime,distance_i): # Eclairement reçu par le segment i après 1 tour
    """les variables angle_i et distance_i sont des liste qui contiennent respecivement les angles et les distances du milieu i avec tous les milieus de l'autre côté"""
    Ei=0
    N=len(angle_i) # Nb d'itérations = nb de segments (pour avoir toutes les contributions)
    for j in range(N): 
        Ei += Eij(Lum_liste[j],dl,dl_prime,angle_i[j],angle_i_prime[j],distance_i[j]) # Somme des contributions de chaque segment j de l'autre plaque
    return Ei

#Récepteur
Er_initial=Eij(Lum0,dL,hr,angle_r[plaque_initiale][indice_initial],angle_r_prime[plaque_initiale][indice_initial],distance_r[plaque_initiale][indice_initial])  #Valeur arrivant sur le récepteur sans perturbations du téléscope
Er_tot=Er_initial #éclairement total qui arrive sur le récépteur
Er=[0 for n in range(n_tours)] #contribution de chaque tour sur l'éclairement

#Récurrence
"""La boucle qui suit permet de calculer l'éclairement à chaque tour : lorsque le numéro du tour est pair on calcule l'éclairement sur la plaque du haut, lorsqu'il est impair, sur la plaque du bas"""

for n in range(n_tours):
    if n%2 == 0: # Si le numéro du tour est pair
        for i in range(len(E[1])): # len(E[1]) = nb de segments sur une plaque
            E[1][i]=Ei(Lum[0],dL,dL,angle[i],angle[i],distance[i]) # Eclairement reçu par le segment i de la plaque 1 (plaque du bas) après n tours
            Lum[1][i]=E[1][i]*R/(np.pi)
        Er[n]=Ei(Lum[0],dL,hr,angle_r[1],angle_r_prime[1],distance_r[1]) # Eclairement reçu par le récepteur après n tours
        #print(E)
    else: # Si le numéro du tour est impair
        for i in range(len(E[0])): # len(E[0]) = len(E[1]) = nb de segments sur une plaque
            E[0][i]=Ei(Lum[1],dL,dL,angle[i],angle[i],distance[i]) # Eclairement reçu par le segment i de la plaque 0 (plaque du haut) après n tours
            Lum[0][i]=E[0][i]*R/(np.pi)
        Er[n]=Ei(Lum[1],dL,hr,angle_r[0],angle_r_prime[0],distance_r[0]) # Eclairement reçu par le récepteur après n tours
        #print(E)

#%%Exploitation des résultats

#Représentation graphique des proportions de chaque contribution parasites (histogramme ?)
X=[n for n in range(n_tours+1)]
Y=[Er_initial]+Er

plt.plot(X,Y)
plt.show()





