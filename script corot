#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Nov 13 15:23:22 2025

@author: lucieremy
"""

########### Initialisation des variables #######################

L= 10 #longueur des plaques
dL= L/10 # intervalle de discrétisation 
h= 3 # distance entre les plaques
hr= 1 # hauteur entre la plaque du bas et le récepteur
d= 2 # distance entre la fin de la plaque et le récépteur
Lr= 1 # largeur du récépteur
E0= 1 # Eclairement du soleil normalisé en W/m2 
Lum= 0 # Luminance dans le cas lambertien A DETERMINER 
M = 0# Emittance A DETERMINER 
R= 0.01 # Reflectance de la peinture ie ce que la pleinture reflete >0
n_tours= 0 #Nombre de tours de reflexions a deteminer/modifier en fonction de nos besoins

# Formule: dans le cas lambertien et 3D : L=Pi*M 

#%% Discrétisation des plaques

s = [[[] for j in range(11)] for i in range(2)] # liste vide qui va contenir les segments discrétisés des plaques 

for i in range (0,2):
    for j in range (0,11):
        s[i][j]=j*dL # plaque du bas car O
        
#print(s)

#%% Calcul des milieux des segments
milieu=[[[] for j in range(10)] for i in range(2)] # liste vide qui va contenir les milieux des plaques 

for i in range (0,2):
    for j in range (0,10):
        milieu[i][j]=(s[i][j+1]+s[i][j])/2    #calcul du milieu
#print(milieu)

#%% Calcul des distances entre les milieux

distance=[[[] for j in range(10)] for i in range(10)]  # liste vide qui contiendra la distance entre le milieu i d'une plaque et le milieu j de l'autre plaque 

for i in range (0,10):
    for j in range (0,10):
        d = np.sqrt((milieu[0][i]-milieu[1][j])**2 + h**2)
        distance[i][j]= d # d[i][j] donne la distance entre le milieu i d'une plaque et le milieu j de l'autre plaque 
        
#print(distance)

#%% Calcul des angles entre les milieux

angle=[[[] for j in range(10)] for i in range(10)]  # liste vide qui contiendra l'angle entre le milieu i d'une plaque et le milieu j de l'autre plaque

for i in range (0,10):
    for j in range (0,10):
        angle[i][j]= arccos(dL/distance[i][j]) # donne l'angle entre le milieu i d'une plaque et le milieu j de l'autre plaque 
#print(angle)

#%% Formules 

def d2phi(Lum,ds,ds_prime,theta,theta_prime,d) :
    d2phi = (Lum*ds*ds_prime*np.cos(theta)*np.cos(theta_prime))/(d**2)
    #Formule du flux que Lemarquis nous a donné dans le cas 3D !! A DETERMINER EN 2D
    return d2phi 

#%% Calcul de la quantité de lumière reçue

#Initialisation
E=[[[] for j in range(10)] for n in range(2)] # liste vide qui va contenir l'éclairement total reçu par élément dl par tour

#Lumière de l'emetteur sur la plaque A REFLECHIR


#Fonctions
def Eij(Lum,ds,ds_prime,theta,theta_prime,d): #contribution d'une fraction dl_prime à l'éclairement d'un élément dl
    phi=d2phi(Lum,ds,ds_prime,theta,theta_prime,d)
    return phi/ds #Basé sur la formule en 3D !!!!

def Ei(Lum,ds,ds_prime,angle_i,angle_i_prime,distance_i): #eclairement d'un élément dl à chaque tour
    """les variables angle_i et distance_i sont des liste qui contiennent respecivement les angles et les distances du milieu i avec tous les milieus de l'aurte côté"""
    Ei=0
    N=len(angle_i) #Permet d'avoir le bon nombre de boucles
    for j in range(N):
        Ei += Eij(Lum,ds,ds_prime,angle_i[j],angle_i_prime[j],distance_i[j]) #somme des contributions de chaque dl
    return Ei

#Récurrence
"""La boucle qui va suivre permet de calculer l'éclairement à chaque tour : lorsque le numéro du tour est pair on calcule la puissance sur la plaque du haut, lorsqu'il est impair, sur la plaque du bas"""
for n in range(n_tours):
    if n%2 == 0:
        for i in range(len(E[1]):
            E[1][i]=Ei(Lum,dL,dL,angle[i],angle[i],distance[i])
    else:
      for i in range(len(E[0]):
            E[0][i]=Ei(Lum,dL,dL,angle[i],angle[i],distance[i])
